//! Protected buffer
//!
use alloc::heap;
use serialize::{Encodable, Encoder, Decodable, Decoder};
use serialize::hex::ToHex;
use std::fmt;
use std::intrinsics;
use std::iter::AdditiveIterator;
use std::kinds::marker::NoSync;
use std::mem;
use std::num::Int;
use std::ops;
use std::ptr;
use std::rand::Rng;
use std::raw::Slice;
use std::slice::{Items, MutItems};

use allocator::{Allocator, KeyAllocator};
use key::ProtKey;
use utils;


/// Buffer of bytes
pub type ProtBuf8<A> = ProtBuf<A, u8>;


unsafe fn alloc<A: Allocator, T>(count: uint) -> *mut T {
    let size = count.checked_mul(mem::size_of::<T>()).unwrap();

    // allocate
    let ptr = Allocator::allocate(None::<A>, size,
                                  mem::min_align_of::<T>()) as *mut T;
    assert!(ptr.is_not_null());
    ptr
}

unsafe fn dealloc<A: Allocator, T>(ptr: *mut T, count: uint) {
    let size = count.checked_mul(mem::size_of::<T>()).unwrap();

    // deallocate
    Allocator::deallocate(None::<A>, ptr as *mut u8, size,
                          mem::min_align_of::<T>());
}


/// A protected Buffer
///
/// Fixed-length buffer used to handle sensible data. Try to minimize
/// data copy and zero-out memory on deallocation.
///
/// Such a protected buffer must be associated with a protected memory
/// allocator responsible for allocating and deallocating its memory.
///
/// A `ProtBuf` instance always provides a read/write access to its memory
/// elements. See `ProtKey` for more controlled access.
///
/// ```rust
/// # extern crate tars;
/// # use tars::allocator::{ProtectedBufferAllocator, ProtectedKeyAllocator};
/// # use tars::ProtBuf;
/// # use tars::ProtKey;
/// # fn my_function(_: &mut [u8]) {}
/// # fn main() {
/// // Create a new buffer of bytes
/// let mut buf: ProtBuf<ProtectedBufferAllocator, u8> = ProtBuf::new_zero(42);
/// assert!(buf[21] == 0);
///
/// // Use a slice to access and manipulate the underlying memory buffer
/// my_function(buf.as_mut_slice());
///
/// // Create a new random key
/// let key: ProtKey<ProtectedKeyAllocator, u8> =
///      ProtBuf::new_rand_os(42).into_key();
/// # }
/// ```
pub struct ProtBuf<A, T> {
    len: uint,
    ptr: *mut T,
    nosync: NoSync
}

impl<A: Allocator, T: Copy> ProtBuf<A, T> {
    fn from_raw_parts(length: uint, ptr: *mut T) -> ProtBuf<A, T> {
        ProtBuf {
            len: length,
            ptr: ptr,
            nosync: NoSync
        }
    }

    /// Return the length i.e. the number of elements `T` of this buffer.
    pub fn len(&self) -> uint {
        self.len
    }

    /// Return the size in bytes represented by the elements of this buffer.
    #[doc(hidden)]
    pub fn len_bytes(&self) -> uint {
        self.len.checked_mul(mem::size_of::<T>()).unwrap()
    }

    fn with_length(length: uint) -> ProtBuf<A, T> {
        if mem::size_of::<T>() == 0 || length == 0 {
            return ProtBuf::from_raw_parts(0, 0 as *mut T);
        }

        let ptr = unsafe {
            alloc::<A, T>(length)
        };
        ProtBuf::from_raw_parts(length, ptr)
    }

    /// New allocated buffer with its memory initialized with bytes of
    /// value zero.
    pub fn new_zero(length: uint) -> ProtBuf<A, T> {
        let n = ProtBuf::with_length(length);
        unsafe {
            ptr::zero_memory(n.ptr, length);
        }
        n
    }

    /// Allocate a new buffer of size `length` and fill it with randomly
    /// generated bytes. Use `rng` as random number generator.
    pub fn new_rand<R: Rng>(length: uint, rng: &mut R) -> ProtBuf<A, T> {
        let mut n = ProtBuf::with_length(length);
        rng.fill_bytes(unsafe {
            mem::transmute(Slice {
                data: n.as_mut_ptr() as *const u8,
                len: n.len_bytes()
            })
        });
        n
    }

    /// Allocate a new buffer of size `length` and fill it with randomly
    /// generated bytes. Use an instance of `OsRng` as random number
    /// generator.
    pub fn new_rand_os(length: uint) -> ProtBuf<A, T> {
        ProtBuf::new_rand(length, &mut utils::os_rng())
    }

    /// New allocated buffer with its `length` elements initialized from
    /// provided closure `op`.
    pub fn from_fn(length: uint, op: |uint| -> T) -> ProtBuf<A, T> {
        let mut n = ProtBuf::with_length(length);
        for i in range(0u, length) {
            n[i] = op(i);
        }
        n
    }

    /// New buffer with elements copied from slice `values`.
    pub fn from_slice(values: &[T]) -> ProtBuf<A, T> {
        unsafe {
            ProtBuf::from_raw_buf(values.as_ptr(), values.len())
        }
    }

    /// New buffer from unsafe buffer.
    pub unsafe fn from_raw_buf(buf: *const T, length: uint) -> ProtBuf<A, T> {
        assert!(buf.is_not_null());
        let n = ProtBuf::with_length(length);
        ptr::copy_nonoverlapping_memory(n.ptr, buf, n.len);
        n
    }

    /// Build a new instance by concatenating slice `items` together.
    pub fn from_slices(items: &[&[T]]) -> ProtBuf<A, T> {
        let length = items.iter().map(|x| x.len()).sum();
        let n = ProtBuf::with_length(length);
        let mut idx: int = 0;

        unsafe {
            for it in items.iter() {
                ptr::copy_nonoverlapping_memory(n.ptr.offset(idx),
                                                it.as_ptr(), it.len());
                idx += it.len() as int;
            }
        }
        n
    }

    /// Build a new instance by concatenating `ProtBuf` `items` together.
    pub fn from_bufs(items: &[&ProtBuf<A, T>]) -> ProtBuf<A, T> {
        let v: Vec<&[T]> = items.iter().map(|x| (*x)[]).collect();
        ProtBuf::from_slices(v[])
    }

    /// Return an immutable pointer to buffer's memory.
    pub fn as_ptr(&self) -> *const T {
        // (seb) Comment copied from vec.rs:
        // If we have a 0-sized vector, then the base pointer should not be NULL
        // because an iterator over the slice will attempt to yield the base
        // pointer as the first element in the vector, but this will end up
        // being Some(NULL) which is optimized to None.
        if mem::size_of::<T>() == 0 {
            heap::EMPTY as *const T
        } else {
            self.ptr as *const T
        }
    }

    /// Return a mutable pointer to buffer's memory.
    pub fn as_mut_ptr(&mut self) -> *mut T {
        // see above for the 0-size check
        if mem::size_of::<T>() == 0 {
            heap::EMPTY as *mut T
        } else {
            self.ptr
        }
    }

    /// Return a mutable slice into `self`.
    pub fn as_mut_slice(&mut self) -> &mut [T] {
        unsafe {
            mem::transmute(Slice {
                data: self.as_mut_ptr() as *const T,
                len: self.len
            })
        }
    }

    /// Cast `self` with another type and return a slice on it.
    pub fn as_cast<U>(&self) -> &[U] {
        let bytes_size = self.len_bytes();
        let dst_type_size = mem::size_of::<U>();
        assert!(bytes_size > 0 && bytes_size % dst_type_size == 0);
        unsafe {
            mem::transmute(Slice {
                data: self.as_ptr() as *const U,
                len: bytes_size / dst_type_size
            })
        }
    }

    /// Cast `self` with another type and return a mut slice on it.
    pub fn as_mut_cast<U>(&mut self) -> &mut [U] {
        let bytes_size = self.len_bytes();
        let dst_type_size = mem::size_of::<U>();
        assert!(bytes_size > 0 && bytes_size % dst_type_size == 0);
        unsafe {
            mem::transmute(Slice {
                data: self.as_ptr() as *const U,
                len: bytes_size / dst_type_size
            })
        }
    }

    /// Return a reference to the value at index `index`. Fails if
    /// `index` is out of bounds.
    pub fn get(&self, index: uint) -> &T {
        &self[][index]
    }

    /// Return a mutable reference to the value at index `index`. Fails
    /// if `index` is out of bounds.
    pub fn get_mut(&mut self, index: uint) -> &mut T {
        &mut self[mut][index]
    }

    /// Return an iterator over references to the elements of the buffer
    /// in order.
    pub fn iter(&self) -> Items<T> {
        self[].iter()
    }

    /// Return an iterator over mutable references to the elements of the
    /// buffer in order.
    pub fn iter_mut(&mut self) -> MutItems<T> {
        self[mut].iter_mut()
    }

    /// Return a slice of self spanning the interval [`start`, `end`).
    /// Fails when the slice (or part of it) is outside the bounds of self,
    /// or when `start` > `end`.
    pub fn slice(&self, start: uint, end: uint) -> &[T] {
        self[][start..end]
    }

    /// Return a mutable slice of `self` between `start` and `end`.
    /// Fails when `start` or `end` point outside the bounds of `self`, or when
    /// `start` > `end`.
    pub fn slice_mut(&mut self, start: uint, end: uint) -> &mut [T] {
        self[mut][mut start..end]
    }

    /// Return a slice of `self` from `start` to the end of the buffer.
    /// Fails when `start` points outside the bounds of self.
    pub fn slice_from(&self, start: uint) -> &[T] {
        self[][start..]
    }

    /// Return a mutable slice of self from `start` to the end of the buffer.
    /// Fails when `start` points outside the bounds of self.
    pub fn slice_from_mut(&mut self, start: uint) -> &mut [T] {
        self[mut][mut start..]
    }

    /// Return a slice of self from the start of the buffer to `end`.
    /// Fails when `end` points outside the bounds of self.
    pub fn slice_to(&self, end: uint) -> &[T] {
        self[][..end]
    }

    /// Return a mutable slice of self from the start of the buffer to `end`.
    /// Fails when `end` points outside the bounds of self.
    pub fn slice_to_mut(&mut self, end: uint) -> &mut [T] {
        self[mut][mut ..end]
    }

    /// Return a pair of mutable slices that divides the buffer at an index.
    ///
    /// The first will contain all indices from `[0, mid)` (excluding the
    /// index `mid` itself) and the second will contain all indices from
    /// `[mid, len)` (excluding the index `len` itself). Fails if
    /// `mid > len`.
    pub fn split_at_mut(&mut self, mid: uint) -> (&mut [T], &mut [T]) {
        self[mut].split_at_mut(mid)
    }

    /// Reverse the order of elements in a buffer, in place.
    pub fn reverse(&mut self) {
        self[mut].reverse()
    }
}

impl<A: Allocator, T: Copy> AsSlice<T> for ProtBuf<A, T> {
    /// Return a slice into `self`.
    fn as_slice(&self) -> &[T] {
        unsafe {
            mem::transmute(Slice {
                data: self.as_ptr(),
                len: self.len
            })
        }
    }
}

impl<A: KeyAllocator, T: Copy> ProtBuf<A, T> {
    /// Transform `self` into a protected key `ProtKey`.
    pub fn into_key(self) -> ProtKey<A, T> {
        ProtKey::new(self)
    }
}

impl<A: Allocator, T: FromPrimitive + Copy> ProtBuf<A, T> {
    /// New buffer from bytes.
    pub fn from_bytes(bytes: &[u8]) -> ProtBuf<A, T> {
        let len = bytes.len();
        let mut n: ProtBuf<A, T> = ProtBuf::with_length(len);

        for i in range(0u, len) {
            n[i] = FromPrimitive::from_u8(bytes[i]).unwrap();
        }
        n
    }
}

#[unsafe_destructor]
impl<A: Allocator, T: Copy> Drop for ProtBuf<A, T> {
    fn drop(&mut self) {
        if self.len != 0 && self.ptr.is_not_null() && mem::size_of::<T>() != 0 {
            unsafe {
                // There is no explicit drop on each T elements, as T
                // is contrained to Copy it should not be an issue as they
                // do not implement destructors. However there would be an
                // issue to use ptr::read() as it could copy memory slots
                // to temporary objects.
                assert!(!intrinsics::needs_drop::<T>());
                dealloc::<A, T>(self.ptr, self.len)
            }
        }
    }
}

impl<A: Allocator, T: Copy> Clone for ProtBuf<A, T> {
    fn clone(&self) -> ProtBuf<A, T> {
        ProtBuf::from_slice(self[])
    }
}

impl<A: Allocator, T: Copy> Index<uint, T> for ProtBuf<A, T> {
    fn index(&self, index: &uint) -> &T {
        self.get(*index)
    }
}

impl<A: Allocator, T: Copy> IndexMut<uint, T> for ProtBuf<A, T> {
    fn index_mut(&mut self, index: &uint) -> &mut T {
        self.get_mut(*index)
    }
}

impl<A: Allocator, T: Copy> ops::Slice<uint, [T]> for ProtBuf<A, T> {
    fn as_slice_<'a>(&'a self) -> &'a [T] {
        self.as_slice()
    }

    fn slice_from_or_fail<'a>(&'a self, start: &uint) -> &'a [T] {
        self.as_slice().slice_from_or_fail(start)
    }

    fn slice_to_or_fail<'a>(&'a self, end: &uint) -> &'a [T] {
        self.as_slice().slice_to_or_fail(end)
    }

    fn slice_or_fail<'a>(&'a self, start: &uint, end: &uint) -> &'a [T] {
        self.as_slice().slice_or_fail(start, end)
    }
}

impl<A: Allocator, T: Copy> ops::SliceMut<uint, [T]> for ProtBuf<A, T> {
    fn as_mut_slice_<'a>(&'a mut self) -> &'a mut [T] {
        self.as_mut_slice()
    }

    fn slice_from_or_fail_mut<'a>(&'a mut self, start: &uint) -> &'a mut [T] {
        self.as_mut_slice().slice_from_or_fail_mut(start)
    }

    fn slice_to_or_fail_mut<'a>(&'a mut self, end: &uint) -> &'a mut [T] {
        self.as_mut_slice().slice_to_or_fail_mut(end)
    }

    fn slice_or_fail_mut<'a>(&'a mut self, start: &uint,
                             end: &uint) -> &'a mut [T] {
        self.as_mut_slice().slice_or_fail_mut(start, end)
    }
}

impl<A: Allocator, T: Copy> ops::Deref<[T]> for ProtBuf<A, T> {
    fn deref(&self) -> &[T] {
        self.as_slice()
    }
}

impl<A: Allocator, T: Copy> ops::DerefMut<[T]> for ProtBuf<A, T> {
    fn deref_mut(&mut self) -> &mut [T] {
        self.as_mut_slice()
    }
}

impl<A: Allocator, T: Copy> PartialEq for ProtBuf<A, T> {
    fn eq(&self, other: &ProtBuf<A, T>) -> bool {
        utils::bytes_eq(self[], other[])
    }
}

impl<A: Allocator, T: Copy> Eq for ProtBuf<A, T> {
}

impl<A: Allocator, T: fmt::Show + Copy> fmt::Show for ProtBuf<A, T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self[].fmt(f)
    }
}

impl<A: Allocator,
     E,
     S: Encoder<E>,
     T: Encodable<S, E> + Copy> Encodable<S, E> for ProtBuf<A, T> {
    fn encode(&self, s: &mut S) -> Result<(), E> {
        self[].encode(s)
    }
}

impl<A: Allocator,
     E,
     D: Decoder<E>,
     T: Decodable<D, E> + Copy> Decodable<D, E> for ProtBuf<A, T> {
    fn decode(d: &mut D) -> Result<ProtBuf<A, T>, E> {
        d.read_seq(|d, len| {
            let mut n = ProtBuf::with_length(len);
            for i in range(0u, len) {
                n[i] = try!(d.read_seq_elt(i, |d| Decodable::decode(d)));
            }
            Ok(n)
        })
    }
}

impl<A: Allocator> ToHex for ProtBuf<A, u8> {
    fn to_hex(&self) -> String {
        self[].to_hex()
    }
}


#[cfg(test)]
mod test {
    use allocator::{NullHeapAllocator, ProtectedBufferAllocator};
    use buf::ProtBuf;


    #[test]
    fn test_basic_dummy() {
        let mut r: [i64, ..256] = [0, ..256];
        let mut s: [u8, ..256] = [0, ..256];

        let a: ProtBuf<NullHeapAllocator, i64> = ProtBuf::new_zero(256);
        assert!(a[] == r[]);

        for i in range(0u, 256) {
            r[i] = i as i64;
            s[i] = i as u8;
        }

        let b: ProtBuf<NullHeapAllocator, i64> = ProtBuf::from_bytes(s[]);
        assert!(b[] == r[]);

        let c: ProtBuf<NullHeapAllocator, i64> = ProtBuf::from_slice(r[]);
        assert!(c[] == r[]);

        let d: ProtBuf<NullHeapAllocator, i64> = unsafe {
            ProtBuf::from_raw_buf(c.as_ptr(), c.len())
        };
        assert!(d[] == c[]);

        let e: ProtBuf<NullHeapAllocator, i64> = ProtBuf::from_slice(r[]);
        assert!(d == e);
    }

    #[test]
    fn test_basic_guarded() {
        let mut r: [i64, ..256] = [0, ..256];
        let mut s: [u8, ..256] = [0, ..256];

        let a: ProtBuf<ProtectedBufferAllocator, i64> = ProtBuf::new_zero(256);
        assert!(a[] == r[]);

        for i in range(0u, 256) {
            r[i] = i as i64;
            s[i] = i as u8;
        }

        let b: ProtBuf<ProtectedBufferAllocator, i64> =
            ProtBuf::from_bytes(s[]);
        assert!(b[] == r[]);

        let c: ProtBuf<NullHeapAllocator, i64> = ProtBuf::from_slice(r[]);
        assert!(c[] == r[]);

        let d: ProtBuf<ProtectedBufferAllocator, i64> = unsafe {
            ProtBuf::from_raw_buf(c.as_ptr(), c.len())
        };
        assert!(d[] == c[]);

        let e: ProtBuf<ProtectedBufferAllocator, i64> =
            ProtBuf::from_slice(r[]);
        assert!(d == e);
    }
}
